package ch.ethz.systems.strymon.ds2.flink.nexmark.sources.dirigo;


import ch.ethz.systems.strymon.ds2.flink.nexmark.sources.dirigo.model.AuctionGenerator;
import ch.ethz.systems.strymon.ds2.flink.nexmark.sources.dirigo.model.BidGenerator;
import ch.ethz.systems.strymon.ds2.flink.nexmark.sources.dirigo.model.PersonGenerator;
import ch.ethz.systems.strymon.ds2.flink.nexmark.sources.dirigo.model.data.Bid;
import org.apache.flink.streaming.runtime.operators.windowing.TimestampedValue;

import java.io.Serializable;
import java.util.*;

import static org.apache.flink.util.Preconditions.checkNotNull;

/**
 * A generator for synthetic events. We try to make the data vaguely reasonable. We also ensure most
 * primary key/foreign key relations are correct. Eg: a {@link Bid} event will usually have valid
 * auction and bidder ids which can be joined to already-generated Auction and Person events.
 *
 * <p>To help with testing, we generate timestamps relative to a given {@code baseTime}. Each new
 * event is given a timestamp advanced from the previous timestamp by {@code interEventDelayUs} (in
 * microseconds). The event stream is thus fully deterministic and does not depend on wallclock
 * time.
 */
public class NexmarkGenerator implements Iterator<TimestampedValue<Event>>, Serializable {

    public NexmarkGenerator() {}

    /**
     * The next event and its various timestamps. Ordered by increasing wallclock timestamp, then
     * (arbitrary but stable) event hash order.
     */
    public static class NextEvent implements Comparable<NextEvent> {
        /** When, in wallclock time, should this event be emitted? */
        public final long wallclockTimestamp;

        /** When, in event time, should this event be considered to have occured? */
        public final long eventTimestamp;

        /** The event itself. */
        public final Event event;

        /** The minimum of this and all future event timestamps. */
        public final long watermark;

        public NextEvent(long wallclockTimestamp, long eventTimestamp, Event event, long watermark) {
            this.wallclockTimestamp = wallclockTimestamp;
            this.eventTimestamp = eventTimestamp;
            this.event = event;
            this.watermark = watermark;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
            }

            NextEvent nextEvent = (NextEvent) o;

            return (wallclockTimestamp == nextEvent.wallclockTimestamp
                    && eventTimestamp == nextEvent.eventTimestamp
                    && watermark == nextEvent.watermark
                    && event.equals(nextEvent.event));
        }

        @Override
        public int hashCode() {
            return Objects.hash(wallclockTimestamp, eventTimestamp, watermark, event);
        }

        @Override
        public int compareTo(NextEvent other) {
            int i = Long.compare(wallclockTimestamp, other.wallclockTimestamp);
            if (i != 0) {
                return i;
            }
            return Integer.compare(event.hashCode(), other.event.hashCode());
        }
    }

    /**
     * Configuration to generate events against. Note that it may be replaced by a call to {@link
     * #splitAtEventId}.
     */
    private GeneratorConfig config;

    /** Number of events generated by this generator. */
    private long eventsCountSoFar;

    /** Wallclock time at which we emitted the first event (ms since epoch). Initially -1. */
    private long wallclockBaseTime;

    protected Long timeBasedInput;


    public SortedMap<Long, Integer> bidCount;

    public NexmarkGenerator(GeneratorConfig config, long eventsCountSoFar, long wallclockBaseTime) {
        checkNotNull(config);
        this.config = config;
        this.eventsCountSoFar = eventsCountSoFar;
        this.wallclockBaseTime = wallclockBaseTime;
        this.bidCount = new TreeMap<>();
        timeBasedInput = null;
        if(config.params!=null){
            System.out.println(" ParameterTool " + Arrays.toString(config.params.toMap().entrySet().toArray()));
        }
        this.timeBasedInput = config.params.has("timed")?
                Long.parseLong(config.params.get("timed")):
                null;
    }

    /** Create a fresh generator according to {@code config}. */
    public NexmarkGenerator(GeneratorConfig config) {
        this(config, 0, -1);
    }

    /** Return a deep copy of this generator. */
    public NexmarkGenerator copy() {
        checkNotNull(config);
        return new NexmarkGenerator(config, eventsCountSoFar, wallclockBaseTime);
    }

    /**
     * Return the current config for this generator. Note that configs may be replaced by {@link
     * #splitAtEventId}.
     */
    public GeneratorConfig getCurrentConfig() {
        return config;
    }

    /**
     * Mutate this generator so that it will only generate events up to but not including {@code
     * eventId}. Return a config to represent the events this generator will no longer yield. The
     * generators will run in on a serial timeline.
     */
    public GeneratorConfig splitAtEventId(long eventId) {
        long newMaxEvents = eventId - (config.firstEventId + config.firstEventNumber);
        GeneratorConfig remainConfig =
                config.copyWith(
                        config.firstEventId,
                        config.maxEvents - newMaxEvents,
                        config.firstEventNumber + newMaxEvents);
        config = config.copyWith(config.firstEventId, newMaxEvents, config.firstEventNumber);
        return remainConfig;
    }

    /**
     * Return the next 'event id'. Though events don't have ids we can simulate them to help with
     * bookkeeping.
     */
    public long getNextEventId() {
        return config.firstEventId + config.nextAdjustedEventNumber(eventsCountSoFar);
    }

    @Override
    public boolean hasNext() {
        if(timeBasedInput==null) return eventsCountSoFar < config.maxEvents;
        if(wallclockBaseTime>=0 && (System.currentTimeMillis() - wallclockBaseTime > timeBasedInput)){
            return false;
        }
        return true;
    }

    public Long nextTS() {
        if(config.baseTime != 0 ) config.baseTime = 0L;
        long eventTimestamp = config.timestampForEvent(config.nextEventNumber(eventsCountSoFar));
        eventsCountSoFar += config.getBatchSize();
        return eventTimestamp;
        //return nextEvent().eventTimestamp;
    }
    /**
     * Return the next event. The outer timestamp is in wallclock time and corresponds to when the
     * event should fire. The inner timestamp is in event-time and represents the time the event is
     * purported to have taken place in the simulation.
     */
    public NextEvent nextEvent() {
        if (wallclockBaseTime < 0) {
            wallclockBaseTime = System.currentTimeMillis();
        }
        // When, in event time, we should generate the event. Monotonic.
        long eventTimestamp = config.timestampForEvent(config.nextEventNumber(eventsCountSoFar));
        // When, in event time, the event should say it was generated. Depending on outOfOrderGroupSize
        // may have local jitter.
        long adjustedEventTimestamp = config.timestampForEvent(config.nextAdjustedEventNumber(eventsCountSoFar));
        // The minimum of this and all future adjusted event timestamps. Accounts for jitter in
        // the event timestamp.
        long watermark = config.timestampForEvent(config.nextEventNumberForWatermark(eventsCountSoFar));
        // When, in wallclock time, we should emit the event.
        long wallclockTimestamp = wallclockBaseTime + (eventTimestamp - getCurrentConfig().baseTime);

        // Seed the random number generator with the next 'event id'.
        Random random = new Random(getNextEventId());

        long newEventId = getNextEventId();
        long rem = newEventId % config.totalProportion;

        Event event;
        if (rem < config.personProportion) {
            event =
                    new Event(PersonGenerator.nextPerson(newEventId, random, adjustedEventTimestamp, config));
        } else if (rem < config.personProportion + config.auctionProportion) {
            event =
                    new Event(
                            AuctionGenerator.nextAuction(eventsCountSoFar, newEventId, random, adjustedEventTimestamp, config));
        } else {
            Bid nextBid = BidGenerator.nextBid(newEventId, random, adjustedEventTimestamp, config);
            event = new Event(nextBid);
            if(!bidCount.containsKey(nextBid.auction)) bidCount.put(nextBid.auction, 0);
            int count = bidCount.get(nextBid.auction);
            bidCount.put(nextBid.auction,count+1);
        }

        eventsCountSoFar++;
        return new NextEvent(wallclockTimestamp, adjustedEventTimestamp, event, watermark);
    }

    public ArrayList<NextEvent> nextEvents(int size) {
//        if (wallclockBaseTime < 0) {
//            wallclockBaseTime = System.currentTimeMillis();
//        }
        if (wallclockBaseTime < 0) {
            wallclockBaseTime = 0L;
        }
        // When, in event time, we should generate the event. Monotonic.
        long eventTimestamp = config.timestampForEvent(config.nextEventNumber(eventsCountSoFar));
        // When, in event time, the event should say it was generated. Depending on outOfOrderGroupSize
        // may have local jitter.
        long adjustedEventTimestamp = config.timestampForEvent(config.nextAdjustedEventNumber(eventsCountSoFar));
        // The minimum of this and all future adjusted event timestamps. Accounts for jitter in
        // the event timestamp.
        long watermark = config.timestampForEvent(config.nextEventNumberForWatermark(eventsCountSoFar));
        // When, in wallclock time, we should emit the event.
        long wallclockTimestamp = wallclockBaseTime + (eventTimestamp - getCurrentConfig().baseTime);

        // Seed the random number generator with the next 'event id'.
        Random random = new Random(getNextEventId());

        long newEventId = getNextEventId();
        long rem = newEventId % config.totalProportion;

        ArrayList<NextEvent> events = new ArrayList<>();
        for(int i = 0; i < size; i++){
            Event event;
            if (rem < config.personProportion) {
                event =
                        new Event(PersonGenerator.nextPerson(newEventId, random, adjustedEventTimestamp, config));
            } else if (rem < config.personProportion + config.auctionProportion) {
                event =
                        new Event(
                                AuctionGenerator.nextAuction(eventsCountSoFar, newEventId, random, adjustedEventTimestamp, config));
            } else {
                Bid nextBid = BidGenerator.nextBid(newEventId, random, adjustedEventTimestamp, config);
                event = new Event(nextBid);
//                if(!bidCount.containsKey(nextBid.auction)) bidCount.put(nextBid.auction, 0);
//                int count = bidCount.get(nextBid.auction);
//                bidCount.put(nextBid.auction,count+1);
            }
            events.add(new NextEvent(wallclockTimestamp, adjustedEventTimestamp, event, watermark));
        }
        eventsCountSoFar++;
        return events;
    }

    public SortedMap<Long, Integer> getBidCountMap(){
        return bidCount;
    }

    @Override
    public TimestampedValue<Event> next() {
        NextEvent next = nextEvent();
        return new TimestampedValue<>(next.event, next.eventTimestamp);
    }

    @Override
    public void remove() {
        throw new UnsupportedOperationException();
    }

    /** Return an estimate of fraction of output consumed. */
    public double getFractionConsumed() {
        return (double) eventsCountSoFar / config.maxEvents;
    }

    /**
     * Gets Number of events generated by this generator.
     */
    public long getEventsCountSoFar() {
        return eventsCountSoFar;
    }

    @Override
    public String toString() {
        return String.format(
                "Generator{config:%s; eventsCountSoFar:%d; wallclockBaseTime:%d}",
                config, eventsCountSoFar, wallclockBaseTime);
    }
}
