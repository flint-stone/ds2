package ch.ethz.systems.strymon.ds2.flink.nexmark.sources.dirigo;


//import generator.GeneratorConfig;
//import generator.NexmarkGenerator;
//import generator.model.AuctionGenerator;
//import generator.model.BidGenerator;
//import generator.model.PersonGenerator;
import ch.ethz.systems.strymon.ds2.flink.nexmark.sources.dirigo.model.AuctionGenerator;
import ch.ethz.systems.strymon.ds2.flink.nexmark.sources.dirigo.model.BidGenerator;
import ch.ethz.systems.strymon.ds2.flink.nexmark.sources.dirigo.model.PersonGenerator;
import ch.ethz.systems.strymon.ds2.flink.nexmark.sources.dirigo.model.data.Bid;
import ch.ethz.systems.strymon.ds2.flink.nexmark.sources.dirigo.utils.NexmarkUtils;
//import model.Bid;
//import model.Event;
//import utils.NexmarkUtils;

import java.io.*;
import java.util.*;

import static org.apache.flink.util.Preconditions.checkNotNull;

/**
 * A generator for synthetic events. We try to make the data vaguely reasonable. We also ensure most
 * primary key/foreign key relations are correct. Eg: a {@link Bid} event will usually have valid
 * auction and bidder ids which can be joined to already-generated Auction and Person events.
 *
 * <p>To help with testing, we generate timestamps relative to a given {@code baseTime}. Each new
 * event is given a timestamp advanced from the previous timestamp by {@code interEventDelayUs} (in
 * microseconds). The event stream is thus fully deterministic and does not depend on wallclock
 * time.
 */
public class NexmarkZipfGenerator extends NexmarkGenerator { //implements Iterator<TimestampedValue<Event>>, Serializable {

    /**
     * Configuration to generate events against. Note that it may be replaced by a call to {@link
     * #splitAtEventId}.
     */
    private GeneratorConfig config;

    /** Number of events generated by this generator. */
    private long eventsCountSoFar;

    private long eventsSentSoFar;

    /** Wallclock time at which we emitted the first event (ms since epoch). Initially -1. */
    private long wallclockBaseTime;


    public SortedMap<Long, Integer> bidCount;

    private NexmarkUtils.FastZipfGenerator zipfGenerator;

    private ArrayList<NextEvent> zipfNextEventBuffer;

    private ArrayList<Long> zipfNextTSBuffer;

    private Long sampleIntervalMillis = 1000L;

    private Long lastTS = Long.MIN_VALUE;

    private long eventId;

    private String filename;

    private BufferedReader br;

    private boolean fromFile = false;

    private int taskId;



    public NexmarkZipfGenerator(GeneratorConfig config, long eventsCountSoFar, long wallclockBaseTime, int taskId) {
        checkNotNull(config);
        this.config = config;
        this.eventsCountSoFar = eventsCountSoFar;
        this.eventsSentSoFar = eventsCountSoFar;
        this.wallclockBaseTime = Long.MIN_VALUE;
        this.bidCount = new TreeMap<>();
        this.zipfNextEventBuffer = new ArrayList<>();
        this.zipfNextTSBuffer = new ArrayList<>();
        this.taskId = taskId;
        double skew = 0.6;
        if(config.rateShape == NexmarkUtils.RateShape.ZIPF){
            if(config.params.has("skew")){
                skew = Double.parseDouble(config.params.get("skew"));
            }
            this.zipfGenerator = new NexmarkUtils.FastZipfGenerator(skew, 1000, 1000000/config.interEventDelayUs[0]);
        }
        filename = System.getenv("FLINK_SRC") + "/zipfRate/zipfRateFileT" + taskId + "D"+ config.interEventDelayUs[0] + "B" + config.getBatchSize()+"S" + skew + ".txt";
        File rateFile = new File(filename);
        try {
            rateFile.createNewFile();
            System.out.println("File created: " + rateFile.getName() + " Path " + filename);
        } catch (IOException e) {
            System.out.println("File create error with path " + filename);
            e.printStackTrace();
        }


        if(config.params.has("fromfile")){
            fromFile = Boolean.parseBoolean(config.params.get("fromfile"));
        }
        // File read
        if(fromFile){
            try {
                br = new BufferedReader(new FileReader(filename));

                String line;

                try {
                    long baseTime = 0;
                    int batchCount = 0;
                    while(true){
                        int numItems;
                        line = br.readLine();
                        if(line != null){
                            numItems = Integer.parseInt(line);
                        }
                        else{
                            System.out.println("Complete initializing (from file) timestamp buffer taskId " + taskId + " of size " + zipfNextTSBuffer.size() + " batch size " + config.getBatchSize());
                            break;
                        }
//                    System.out.println("Generating ts based on file load "
//                            + " numItems "+ numItems
//                            + " basetime " + wallclockBaseTime + " lastTS " + lastTS
//                            + " tid: " + Thread.currentThread());
//                System.out.println("Next numItems " + numItems + " lastTS " + lastTS + " tid: " + Thread.currentThread().getName());
                        for(int i = 0; i< numItems; i++){
                            // When, in event time, we should generate the event. Monotonic.
                            long eventTimestamp = config.timestampForEventZipf(baseTime, sampleIntervalMillis*i/numItems);
                            batchCount ++;
                            // eventsCountSoFar++;
                            if(batchCount % config.getBatchSize() == 0) {
                                zipfNextTSBuffer.add(eventTimestamp);
                            }
                        }
                        baseTime = baseTime + sampleIntervalMillis;
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                    try {
                        br.close();
                    } catch (IOException e2) {
                        e2.printStackTrace();
                    }
                }


            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
        }
        else{
            rateFile.delete();
            FileWriter fileWriter = null;
            try {
                long baseTime = 0;
                int batchCount = 0;
                int numItems;
                while(true){
                    if(batchCount > config.maxEvents) {
                        System.out.println("Complete initializing (from generator) timestamp buffer taskId " + taskId + " of size " + zipfNextTSBuffer.size()
                                + " batch size " + config.getBatchSize() + " batchCount " + batchCount + " maxEvents " + config.maxEvents);
                        break;
                    }
                    if(baseTime < GeneratorConfig.ZIPF_WARMUP_MILLIS){
                        numItems = (int) (1000000/(config.interEventDelayUs[0]));
                    }
                    else{
                        numItems = zipfGenerator.next();
                    }
                    fileWriter = new FileWriter(filename, true);
                    fileWriter.append(numItems+"\n");
                    fileWriter.close();
                    for(int i = 0; i< numItems; i++){
                        batchCount ++;
                        // When, in event time, we should generate the event. Monotonic.
                        long eventTimestamp = config.timestampForEventZipf(baseTime, sampleIntervalMillis*i/numItems);
                        if(batchCount % config.getBatchSize() == 0) {
                            zipfNextTSBuffer.add(eventTimestamp);
                        }
                    }
                    baseTime = baseTime + sampleIntervalMillis;
                }
            } catch (IOException e) {
                try {
                    if(fileWriter!=null) fileWriter.close();
                } catch (IOException ioException) {
                    ioException.printStackTrace();
                }
            }

        }
        System.out.println("Timestamp buffer generated with alpha " + skew + " at task Id " + taskId + " zipfNextTSBuffer " + Arrays.toString(zipfNextTSBuffer.toArray()));
    }

    /** Create a fresh generator according to {@code config}. */
    public NexmarkZipfGenerator(GeneratorConfig config, int taskId) {
        this(config, 0, -1, taskId);
    }

    /** Return a deep copy of this generator. */
    public NexmarkGenerator copy() {
        checkNotNull(config);
        return new NexmarkGenerator(config, eventsCountSoFar, wallclockBaseTime);
    }

    /**
     * Return the current config for this generator. Note that configs may be replaced by {@link
     * #splitAtEventId}.
     */
    public GeneratorConfig getCurrentConfig() {
        return config;
    }

    /**
     * Mutate this generator so that it will only generate events up to but not including {@code
     * eventId}. Return a config to represent the events this generator will no longer yield. The
     * generators will run in on a serial timeline.
     */
    public GeneratorConfig splitAtEventId(long eventId) {
        long newMaxEvents = eventId - (config.firstEventId + config.firstEventNumber);
        GeneratorConfig remainConfig =
                config.copyWith(
                        config.firstEventId,
                        config.maxEvents - newMaxEvents,
                        config.firstEventNumber + newMaxEvents);
        config = config.copyWith(config.firstEventId, newMaxEvents, config.firstEventNumber);
        this.eventId = eventId;
        return remainConfig;
    }

    /**
     * Return the next 'event id'. Though events don't have ids we can simulate them to help with
     * bookkeeping.
     */
    public long getNextEventId() {
        return config.firstEventId + config.nextAdjustedEventNumber(eventsCountSoFar);
    }

    @Override
    public boolean hasNext() {
        if(timeBasedInput==null) return eventsSentSoFar < config.maxEvents;
        if(System.currentTimeMillis() - wallclockBaseTime > timeBasedInput ){
            return false;
        }
        return true;
    }

    /**
     * Return the next event. The outer timestamp is in wallclock time and corresponds to when the
     * event should fire. The inner timestamp is in event-time and represents the time the event is
     * purported to have taken place in the simulation.
     * @return
     */
    public NextEvent nextEvent() {

//        if (wallclockBaseTime < 0) {
//            wallclockBaseTime = getCurrentConfig().baseTime;
//        }
//        if (lastTS == Long.MIN_VALUE){
//            lastTS = getCurrentConfig().baseTime;
//        }
        if (wallclockBaseTime < 0) {
            wallclockBaseTime = 0L; //getCurrentConfig().baseTime;
        }
        if (lastTS == Long.MIN_VALUE){
            lastTS = 0L; // getCurrentConfig().baseTime;
        }

        if(zipfNextEventBuffer.isEmpty()){
            Integer numItems = null;
            if(fromFile){
                // WRITE
//            FileWriter fileWriter = null;
//            try {
//                fileWriter = new FileWriter(filename, true);
//                fileWriter.append(numItems+"\n");
//                fileWriter.close();
//            } catch (IOException e) {
//                try {
//                    if(fileWriter!=null) fileWriter.close();
//                } catch (IOException ioException) {
//                    ioException.printStackTrace();
//                }
//            }

                // READ
                String line;
                try {
                    line = br.readLine();
                    if(line != null){
                        numItems = Integer.parseInt(line);
                    }
                    else{
                        numItems = (int) (1000000/(config.interEventDelayUs[0]));
                    }
//                    System.out.println("Generating ts based on file load "
//                            + " numItems "+ numItems
//                            + " basetime " + wallclockBaseTime + " lastTS " + lastTS
//                            + " tid: " + Thread.currentThread());
                } catch (IOException e) {
                    e.printStackTrace();
                    try {
                        br.close();
                    } catch (IOException e2) {
                        e2.printStackTrace();
                    }
                }
            }
            else{
                if(lastTS < wallclockBaseTime + GeneratorConfig.ZIPF_WARMUP_MILLIS){
                    numItems = (int) (1000000/(config.interEventDelayUs[0]));
//                    System.out.println("Generating ts based on default load "
//                        + " numItems "+ numItems
//                        + " basetime " + wallclockBaseTime + " lastTS " + lastTS
//                        + " tid: " + Thread.currentThread());
                }
                else{
                    numItems = zipfGenerator.next();
//                    System.out.println("Generating ts based on zipf distribution "
//                            + " numItems "+ numItems
//                            + " basetime " + wallclockBaseTime + " lastTS " + lastTS
//                            + " tid: " + Thread.currentThread());
                }
            }
            if(numItems == null) numItems = (int) (1000000/(config.interEventDelayUs[0]));

//                System.out.println("Next numItems " + numItems + " lastTS " + lastTS + " tid: " + Thread.currentThread().getName());
            for(int i = 0; i< numItems; i++){
                // When, in event time, we should generate the event. Monotonic.
                long eventTimestamp = config.timestampForEventZipf(lastTS, sampleIntervalMillis*i/numItems);
                // When, in event time, the event should say it was generated. Depending on outOfOrderGroupSize
                // may have local jitter.
                long adjustedEventTimestamp = config.timestampForEventZipf(lastTS, sampleIntervalMillis*i/numItems);
                // The minimum of this and all future adjusted event timestamps. Accounts for jitter in
                // the event timestamp.
                long watermark = config.timestampForEventZipf(lastTS, sampleIntervalMillis*i/numItems);
                // When, in wallclock time, we should emit the event.
                long wallclockTimestamp = wallclockBaseTime + (eventTimestamp - getCurrentConfig().baseTime);

                // Seed the random number generator with the next 'event id'.
                Random random = new Random(getNextEventId());

                long newEventId = getNextEventId();
                long rem = newEventId % config.totalProportion;

                Event event;
                if (rem < config.personProportion) {
                    event =
                            new Event(PersonGenerator.nextPerson(newEventId, random, adjustedEventTimestamp, config));
                } else if (rem < config.personProportion + config.auctionProportion) {
                    event =
                            new Event(
                                    AuctionGenerator.nextAuction(eventsCountSoFar, newEventId, random, adjustedEventTimestamp, config));
                } else {
                    Bid nextBid = BidGenerator.nextBid(newEventId, random, adjustedEventTimestamp, config);
                    event = new Event(nextBid);
                    if(!bidCount.containsKey(nextBid.auction)) bidCount.put(nextBid.auction, 0);
                    int count = bidCount.get(nextBid.auction);
                    bidCount.put(nextBid.auction,count+1);
                }

                eventsCountSoFar++;
                zipfNextEventBuffer.add(new NextEvent(wallclockTimestamp, adjustedEventTimestamp, event, watermark));
            }
            lastTS = lastTS + sampleIntervalMillis;
        }
        eventsSentSoFar++;
        return zipfNextEventBuffer.remove(0);
    }

    public Long nextTS() {

        if (wallclockBaseTime < 0) {
            wallclockBaseTime = 0L; //getCurrentConfig().baseTime;
        }
        if (lastTS == Long.MIN_VALUE){
            lastTS = 0L; // getCurrentConfig().baseTime;
        }

        if(zipfNextTSBuffer.isEmpty()){
            System.out.println("Reaching the end of file buffer... check new events taskId " + taskId);
            return null;
//            Integer numItems = null;
//            if(fromFile){
//                // READ
//                String line;
//                try {
//                    line = br.readLine();
//                    if(line != null){
//                        numItems = Integer.parseInt(line);
//                    }
//                    else{
//                        numItems = (int) (1000000/(config.interEventDelayUs[0]));
//                    }
////                    System.out.println("Generating ts based on file load "
////                            + " numItems "+ numItems
////                            + " basetime " + wallclockBaseTime + " lastTS " + lastTS
////                            + " tid: " + Thread.currentThread());
//                } catch (IOException e) {
//                    e.printStackTrace();
//                    try {
//                        br.close();
//                    } catch (IOException e2) {
//                        e2.printStackTrace();
//                    }
//                }
//            }
//            else{
//                if(lastTS < wallclockBaseTime + GeneratorConfig.ZIPF_WARMUP_MILLIS){
//                    numItems = (int) (1000000/(config.interEventDelayUs[0]));
////                    System.out.println("Generating ts based on default load "
////                        + " numItems "+ numItems
////                        + " basetime " + wallclockBaseTime + " lastTS " + lastTS
////                        + " tid: " + Thread.currentThread());
//                }
//                else{
//                    numItems = zipfGenerator.next();
////                    System.out.println("Generating ts based on zipf distribution "
////                            + " numItems "+ numItems
////                            + " basetime " + wallclockBaseTime + " lastTS " + lastTS
////                            + " tid: " + Thread.currentThread());
//                }
//            }
//            if(numItems == null) numItems = (int) (1000000/(config.interEventDelayUs[0]));
//
////                System.out.println("Next numItems " + numItems + " lastTS " + lastTS + " tid: " + Thread.currentThread().getName());
//            for(int i = 0; i< numItems; i++){
//                // When, in event time, we should generate the event. Monotonic.
//                long eventTimestamp = config.timestampForEventZipf(lastTS, sampleIntervalMillis*i/numItems);
//
//                eventsCountSoFar++;
//                zipfNextTSBuffer.add(eventTimestamp);
//            }
//            lastTS = lastTS + sampleIntervalMillis;
        }
        eventsSentSoFar++;
        return zipfNextTSBuffer.remove(0);
    }

    @Override
    public SortedMap<Long, Integer> getBidCountMap(){
        return bidCount;
    }

    @Override
    public void remove() {
        throw new UnsupportedOperationException();
    }

    /** Return an estimate of fraction of output consumed. */
    public double getFractionConsumed() {
        return (double) eventsCountSoFar / config.maxEvents;
    }

    /**
     * Gets Number of events generated by this generator.
     */
    public long getEventsCountSoFar() {
        return eventsCountSoFar;
    }

    @Override
    public String toString() {
        return String.format(
                "ZipfGenerator{config:%s; eventsCountSoFar:%d; wallclockBaseTime:%d}",
                config, eventsCountSoFar, wallclockBaseTime);
    }
}
